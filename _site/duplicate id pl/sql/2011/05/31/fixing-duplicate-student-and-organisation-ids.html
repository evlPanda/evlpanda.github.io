<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Fixing Duplicate Student and Organisation IDs | The PeopleSoft Experience</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Fixing Duplicate Student and Organisation IDs" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Like this: -- ************************************************************************************-- CSUPGRD-727 Michael Nitschke 31/05/2011-- Correct situation where Students and Organisations have duplicate IDs.-- This has occurred where users have overwritten the &#39;NEW&#39; value when adding an Org.-- ************************************************************************************BEGIN -- Build working tables for this process. -- This one stores all the Records that will potentially be updated. -- OCCURSCOUNT1 stores rows of data to be updated -- OCCURSCOUNT2 stores rows of data to be updated *after* the fix has been run. Should be 0. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_RECNM&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_RECNM&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_RECNM ( DESCR VARCHAR2(100) NOT NULL, RECNAME VARCHAR2(15) NOT NULL, FIELDNAME VARCHAR2(18) NOT NULL, OCCURSCOUNT1 SMALLINT NOT NULL, OCCURSCOUNT2 SMALLINT NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ; -- This one stores the old EXT_ORG_ID and the new EXT_ORG_ID for each Organisation that is having its ID updated. -- May be useful if something unexpected happens. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_OLDNW&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_OLDNW&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_OLDNW ( EXT_ORG_ID_OLD VARCHAR2(11) NOT NULL, EXT_ORG_ID VARCHAR2(11) NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ;END;/-- This procedure takes a given Record and finds all Records that use it as a prompt, where that prompt field is not EXT_ORG_ID (as record would be picked up in base select already).-- Note that this function is recursive. Use the maxDepth value to set how far down the tree to go.-- Too high a value and you will run out of cursors.CREATE OR REPLACE PROCEDURE FindWhereRecUsedAsPrompt(varRecname VARCHAR2, currentDepth integer) IS CURSOR cRecPrompts IS SELECT &#39;PROMPT&#39; X, A.RECNAME AS RECNAME, A.FIELDNAME AS FIELDNAME FROM PSRECFIELD A , PSRECDEFN B , PSDBFIELD C WHERE A.FIELDNAME &#39;EXT_ORG_ID&#39; AND A.EDITTABLE = varRecname AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 -- SQL Table AND C.FIELDNAME = A.FIELDNAME AND C.FIELDTYPE = 0; -- Character depth integer; maxDepth integer;BEGIN maxDepth:= 1; -- Set how deep you want to traverse down the prompt tables depth:= currentDepth; FOR recP in cRecPrompts LOOP EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || recP.x || &#39;(depth: &#39; || depth || &#39;, parent:&#39; || varRecname || &#39;)&#39;&#39; , &#39;&#39;&#39; || recP.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || recP.FIELDNAME || &#39;&#39;&#39; ,0 ,0)&#39;; IF depth &lt; maxDepth THEN FindWhereRecUsedAsPrompt(recP.RECNAME, depth+1); END IF; END LOOP; depth:= depth-1;END FindWhereRecUsedAsPrompt;/-- This procedure counts number of rows in affected tables.-- It uses the temp table PS_AMS_DUPID_RECNM-- OCCURSCOUNT1 stores the number of rows beofore the fix/update is applied.-- OCCURSCOUNT2 stores the number of rows after the fix/update has been applied (should = 0).CREATE OR REPLACE PROCEDURE analyseRowCount(fldUpdate VARCHAR2) IS CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER;BEGIN FOR rec in cTableList LOOP -- Two steps for legibility&#39;s sake. BEGIN If substr(rec.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); ELSE sqlStatement:= &#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); END IF; EXECUTE IMMEDIATE sqlStatement INTO rowCount; sqlStatement:= &#39;UPDATE PS_AMS_DUPID_RECNM SET &#39; || fldUpdate || &#39; = &#39; || rowCount || &#39; WHERE RECNAME = &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39; AND FIELDNAME = &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;&#39;; EXECUTE IMMEDIATE sqlStatement; EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at analyseRowCount(): &#39; || sqlstatement); END; END LOOP;END analyseRowCount;/-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- &lt;&gt;DECLARE -- Duplicate IDs. CURSOR cDuplicateIDs IS SELECT EXT_ORG_ID FROM PS_EXT_ORG_TBL A WHERE A.EXT_ORG_ID IN (SELECT B.EXT_ORG_ID FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT C.EMPLID FROM PS_PERSONAL_DATA C WHERE C.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7))) --and rownum &lt; 4 -- &lt;&lt; LOOK!!! used for building. ; -- Base tables. -- Tables that have EXT_ORG_ID field. CURSOR cBaseTables IS SELECT &#39;Base&#39; X , A.RECNAME RECNAME , A.FIELDNAME FIELDNAME FROM PSRECFIELD A , PSRECDEFN B WHERE A.FIELDNAME = &#39;EXT_ORG_ID&#39; AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 AND B.RECNAME NOT LIKE &#39;%TMP&#39; AND NOT EXISTS -- Not used as an audit record. (SELECT 1 FROM PSRECDEFN WHERE AUDITRECNAME = RECNAME) ; CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER; newExtOrgId PS_EXT_ORG_TBL.EXT_ORG_ID%type; duplicateID INTEGER;BEGIN -- Loop through the base tables that contain EXT_ORG_ID. FOR rec in cBaseTables LOOP -- Insert into working table a list of both the base tables and any tables that use those base tables as a prompt. -- These are the list of tables that potentially need to be updated. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || rec.x || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;,0 ,0)&#39;; FindWhereRecUsedAsPrompt(rec.RECNAME, 1); END LOOP; -- Now we have a list of tables built we&#39;ll analyse how many rows we expect to update. -- PS_AMS_DUPID_RECNM.OCCURSCOUNT1 stores the number of rows that will be updated. analyseRowCount(&#39;OCCURSCOUNT1&#39;); -- Update the duplicate IDs (this is the really exciting part). For rec in cDuplicateIDs LOOP -- Create a new ID. duplicateID := 1; WHILE duplicateID 0 LOOP SELECT EMPLID_LAST_EMPL + 1 INTO newExtOrgId FROM PS_INSTALLATION; EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_PERSONAL_DATA WHERE EMPLID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; IF duplicateID = 0 THEN EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_EXT_ORG_TBL WHERE EXT_ORG_ID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; --dbms_output.put_line(&#39;duplicateID= &#39; || duplicateID || &#39;, newExtOrgId= &#39; || newExtOrgId); END IF; END LOOP; UPDATE PS_INSTALLATION SET EMPLID_LAST_EMPL = newExtOrgId; -- Update the old value to the new value in every record that has at least one affected row. FOR recUpd in cTableList LOOP If recUpd.OCCURSCOUNT1 &gt; 0 THEN If substr(recUpd.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;UPDATE &#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; ELSE sqlStatement:= &#39;UPDATE PS_&#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; END IF; BEGIN EXECUTE IMMEDIATE sqlStatement; --dbms_output.put_line(sqlStatement); EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at (main program): &#39; || sqlstatement); END; END IF; END LOOP; -- Record the old and new values. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_OLDNW (EXT_ORG_ID_OLD, EXT_ORG_ID) VALUES (&#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;, &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;)&#39;; END LOOP; -- Analyse the number of rows again. We expect 0. -- OCCURSCOUNT2 stores the number of rows post update/fix. Should be 0. analyseRowCount(&#39;OCCURSCOUNT2&#39;);END;/-- Show the analysis/working tables.select * from PS_AMS_DUPID_OLDNW;SELECT * FROM PS_AMS_DUPID_RECNM where occurscount1 &gt; 0;" />
<meta property="og:description" content="Like this: -- ************************************************************************************-- CSUPGRD-727 Michael Nitschke 31/05/2011-- Correct situation where Students and Organisations have duplicate IDs.-- This has occurred where users have overwritten the &#39;NEW&#39; value when adding an Org.-- ************************************************************************************BEGIN -- Build working tables for this process. -- This one stores all the Records that will potentially be updated. -- OCCURSCOUNT1 stores rows of data to be updated -- OCCURSCOUNT2 stores rows of data to be updated *after* the fix has been run. Should be 0. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_RECNM&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_RECNM&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_RECNM ( DESCR VARCHAR2(100) NOT NULL, RECNAME VARCHAR2(15) NOT NULL, FIELDNAME VARCHAR2(18) NOT NULL, OCCURSCOUNT1 SMALLINT NOT NULL, OCCURSCOUNT2 SMALLINT NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ; -- This one stores the old EXT_ORG_ID and the new EXT_ORG_ID for each Organisation that is having its ID updated. -- May be useful if something unexpected happens. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_OLDNW&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_OLDNW&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_OLDNW ( EXT_ORG_ID_OLD VARCHAR2(11) NOT NULL, EXT_ORG_ID VARCHAR2(11) NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ;END;/-- This procedure takes a given Record and finds all Records that use it as a prompt, where that prompt field is not EXT_ORG_ID (as record would be picked up in base select already).-- Note that this function is recursive. Use the maxDepth value to set how far down the tree to go.-- Too high a value and you will run out of cursors.CREATE OR REPLACE PROCEDURE FindWhereRecUsedAsPrompt(varRecname VARCHAR2, currentDepth integer) IS CURSOR cRecPrompts IS SELECT &#39;PROMPT&#39; X, A.RECNAME AS RECNAME, A.FIELDNAME AS FIELDNAME FROM PSRECFIELD A , PSRECDEFN B , PSDBFIELD C WHERE A.FIELDNAME &#39;EXT_ORG_ID&#39; AND A.EDITTABLE = varRecname AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 -- SQL Table AND C.FIELDNAME = A.FIELDNAME AND C.FIELDTYPE = 0; -- Character depth integer; maxDepth integer;BEGIN maxDepth:= 1; -- Set how deep you want to traverse down the prompt tables depth:= currentDepth; FOR recP in cRecPrompts LOOP EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || recP.x || &#39;(depth: &#39; || depth || &#39;, parent:&#39; || varRecname || &#39;)&#39;&#39; , &#39;&#39;&#39; || recP.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || recP.FIELDNAME || &#39;&#39;&#39; ,0 ,0)&#39;; IF depth &lt; maxDepth THEN FindWhereRecUsedAsPrompt(recP.RECNAME, depth+1); END IF; END LOOP; depth:= depth-1;END FindWhereRecUsedAsPrompt;/-- This procedure counts number of rows in affected tables.-- It uses the temp table PS_AMS_DUPID_RECNM-- OCCURSCOUNT1 stores the number of rows beofore the fix/update is applied.-- OCCURSCOUNT2 stores the number of rows after the fix/update has been applied (should = 0).CREATE OR REPLACE PROCEDURE analyseRowCount(fldUpdate VARCHAR2) IS CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER;BEGIN FOR rec in cTableList LOOP -- Two steps for legibility&#39;s sake. BEGIN If substr(rec.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); ELSE sqlStatement:= &#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); END IF; EXECUTE IMMEDIATE sqlStatement INTO rowCount; sqlStatement:= &#39;UPDATE PS_AMS_DUPID_RECNM SET &#39; || fldUpdate || &#39; = &#39; || rowCount || &#39; WHERE RECNAME = &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39; AND FIELDNAME = &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;&#39;; EXECUTE IMMEDIATE sqlStatement; EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at analyseRowCount(): &#39; || sqlstatement); END; END LOOP;END analyseRowCount;/-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- &lt;&gt;DECLARE -- Duplicate IDs. CURSOR cDuplicateIDs IS SELECT EXT_ORG_ID FROM PS_EXT_ORG_TBL A WHERE A.EXT_ORG_ID IN (SELECT B.EXT_ORG_ID FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT C.EMPLID FROM PS_PERSONAL_DATA C WHERE C.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7))) --and rownum &lt; 4 -- &lt;&lt; LOOK!!! used for building. ; -- Base tables. -- Tables that have EXT_ORG_ID field. CURSOR cBaseTables IS SELECT &#39;Base&#39; X , A.RECNAME RECNAME , A.FIELDNAME FIELDNAME FROM PSRECFIELD A , PSRECDEFN B WHERE A.FIELDNAME = &#39;EXT_ORG_ID&#39; AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 AND B.RECNAME NOT LIKE &#39;%TMP&#39; AND NOT EXISTS -- Not used as an audit record. (SELECT 1 FROM PSRECDEFN WHERE AUDITRECNAME = RECNAME) ; CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER; newExtOrgId PS_EXT_ORG_TBL.EXT_ORG_ID%type; duplicateID INTEGER;BEGIN -- Loop through the base tables that contain EXT_ORG_ID. FOR rec in cBaseTables LOOP -- Insert into working table a list of both the base tables and any tables that use those base tables as a prompt. -- These are the list of tables that potentially need to be updated. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || rec.x || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;,0 ,0)&#39;; FindWhereRecUsedAsPrompt(rec.RECNAME, 1); END LOOP; -- Now we have a list of tables built we&#39;ll analyse how many rows we expect to update. -- PS_AMS_DUPID_RECNM.OCCURSCOUNT1 stores the number of rows that will be updated. analyseRowCount(&#39;OCCURSCOUNT1&#39;); -- Update the duplicate IDs (this is the really exciting part). For rec in cDuplicateIDs LOOP -- Create a new ID. duplicateID := 1; WHILE duplicateID 0 LOOP SELECT EMPLID_LAST_EMPL + 1 INTO newExtOrgId FROM PS_INSTALLATION; EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_PERSONAL_DATA WHERE EMPLID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; IF duplicateID = 0 THEN EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_EXT_ORG_TBL WHERE EXT_ORG_ID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; --dbms_output.put_line(&#39;duplicateID= &#39; || duplicateID || &#39;, newExtOrgId= &#39; || newExtOrgId); END IF; END LOOP; UPDATE PS_INSTALLATION SET EMPLID_LAST_EMPL = newExtOrgId; -- Update the old value to the new value in every record that has at least one affected row. FOR recUpd in cTableList LOOP If recUpd.OCCURSCOUNT1 &gt; 0 THEN If substr(recUpd.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;UPDATE &#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; ELSE sqlStatement:= &#39;UPDATE PS_&#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; END IF; BEGIN EXECUTE IMMEDIATE sqlStatement; --dbms_output.put_line(sqlStatement); EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at (main program): &#39; || sqlstatement); END; END IF; END LOOP; -- Record the old and new values. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_OLDNW (EXT_ORG_ID_OLD, EXT_ORG_ID) VALUES (&#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;, &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;)&#39;; END LOOP; -- Analyse the number of rows again. We expect 0. -- OCCURSCOUNT2 stores the number of rows post update/fix. Should be 0. analyseRowCount(&#39;OCCURSCOUNT2&#39;);END;/-- Show the analysis/working tables.select * from PS_AMS_DUPID_OLDNW;SELECT * FROM PS_AMS_DUPID_RECNM where occurscount1 &gt; 0;" />
<link rel="canonical" href="http://localhost:4000/duplicate%20id%20pl/sql/2011/05/31/fixing-duplicate-student-and-organisation-ids.html" />
<meta property="og:url" content="http://localhost:4000/duplicate%20id%20pl/sql/2011/05/31/fixing-duplicate-student-and-organisation-ids.html" />
<meta property="og:site_name" content="The PeopleSoft Experience" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2011-05-31T07:44:00+10:00" />
<script type="application/ld+json">
{"description":"Like this: -- ************************************************************************************-- CSUPGRD-727 Michael Nitschke 31/05/2011-- Correct situation where Students and Organisations have duplicate IDs.-- This has occurred where users have overwritten the &#39;NEW&#39; value when adding an Org.-- ************************************************************************************BEGIN -- Build working tables for this process. -- This one stores all the Records that will potentially be updated. -- OCCURSCOUNT1 stores rows of data to be updated -- OCCURSCOUNT2 stores rows of data to be updated *after* the fix has been run. Should be 0. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_RECNM&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_RECNM&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_RECNM ( DESCR VARCHAR2(100) NOT NULL, RECNAME VARCHAR2(15) NOT NULL, FIELDNAME VARCHAR2(18) NOT NULL, OCCURSCOUNT1 SMALLINT NOT NULL, OCCURSCOUNT2 SMALLINT NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ; -- This one stores the old EXT_ORG_ID and the new EXT_ORG_ID for each Organisation that is having its ID updated. -- May be useful if something unexpected happens. FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = &#39;PS_AMS_DUPID_OLDNW&#39;) LOOP EXECUTE IMMEDIATE &#39;DROP TABLE PS_AMS_DUPID_OLDNW&#39;; END LOOP; EXECUTE IMMEDIATE &#39; CREATE TABLE PS_AMS_DUPID_OLDNW ( EXT_ORG_ID_OLD VARCHAR2(11) NOT NULL, EXT_ORG_ID VARCHAR2(11) NOT NULL) TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80&#39; ;END;/-- This procedure takes a given Record and finds all Records that use it as a prompt, where that prompt field is not EXT_ORG_ID (as record would be picked up in base select already).-- Note that this function is recursive. Use the maxDepth value to set how far down the tree to go.-- Too high a value and you will run out of cursors.CREATE OR REPLACE PROCEDURE FindWhereRecUsedAsPrompt(varRecname VARCHAR2, currentDepth integer) IS CURSOR cRecPrompts IS SELECT &#39;PROMPT&#39; X, A.RECNAME AS RECNAME, A.FIELDNAME AS FIELDNAME FROM PSRECFIELD A , PSRECDEFN B , PSDBFIELD C WHERE A.FIELDNAME &#39;EXT_ORG_ID&#39; AND A.EDITTABLE = varRecname AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 -- SQL Table AND C.FIELDNAME = A.FIELDNAME AND C.FIELDTYPE = 0; -- Character depth integer; maxDepth integer;BEGIN maxDepth:= 1; -- Set how deep you want to traverse down the prompt tables depth:= currentDepth; FOR recP in cRecPrompts LOOP EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || recP.x || &#39;(depth: &#39; || depth || &#39;, parent:&#39; || varRecname || &#39;)&#39;&#39; , &#39;&#39;&#39; || recP.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || recP.FIELDNAME || &#39;&#39;&#39; ,0 ,0)&#39;; IF depth &lt; maxDepth THEN FindWhereRecUsedAsPrompt(recP.RECNAME, depth+1); END IF; END LOOP; depth:= depth-1;END FindWhereRecUsedAsPrompt;/-- This procedure counts number of rows in affected tables.-- It uses the temp table PS_AMS_DUPID_RECNM-- OCCURSCOUNT1 stores the number of rows beofore the fix/update is applied.-- OCCURSCOUNT2 stores the number of rows after the fix/update has been applied (should = 0).CREATE OR REPLACE PROCEDURE analyseRowCount(fldUpdate VARCHAR2) IS CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER;BEGIN FOR rec in cTableList LOOP -- Two steps for legibility&#39;s sake. BEGIN If substr(rec.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM &#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); ELSE sqlStatement:= &#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))&#39;;-- dbms_output.put_line(&#39;SELECT COUNT(*) FROM PS_&#39; || rec.RECNAME || &#39; WHERE SUBSTR(&#39; || rec.FIELDNAME || &#39;,1,7) IN &#39;); END IF; EXECUTE IMMEDIATE sqlStatement INTO rowCount; sqlStatement:= &#39;UPDATE PS_AMS_DUPID_RECNM SET &#39; || fldUpdate || &#39; = &#39; || rowCount || &#39; WHERE RECNAME = &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39; AND FIELDNAME = &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;&#39;; EXECUTE IMMEDIATE sqlStatement; EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at analyseRowCount(): &#39; || sqlstatement); END; END LOOP;END analyseRowCount;/-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- &lt;&gt;DECLARE -- Duplicate IDs. CURSOR cDuplicateIDs IS SELECT EXT_ORG_ID FROM PS_EXT_ORG_TBL A WHERE A.EXT_ORG_ID IN (SELECT B.EXT_ORG_ID FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT C.EMPLID FROM PS_PERSONAL_DATA C WHERE C.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7))) --and rownum &lt; 4 -- &lt;&lt; LOOK!!! used for building. ; -- Base tables. -- Tables that have EXT_ORG_ID field. CURSOR cBaseTables IS SELECT &#39;Base&#39; X , A.RECNAME RECNAME , A.FIELDNAME FIELDNAME FROM PSRECFIELD A , PSRECDEFN B WHERE A.FIELDNAME = &#39;EXT_ORG_ID&#39; AND B.RECNAME = A.RECNAME AND B.RECTYPE = 0 AND B.RECNAME NOT LIKE &#39;%TMP&#39; AND NOT EXISTS -- Not used as an audit record. (SELECT 1 FROM PSRECDEFN WHERE AUDITRECNAME = RECNAME) ; CURSOR cTableList IS SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM ; sqlStatement VARCHAR2(300); rowCount INTEGER; newExtOrgId PS_EXT_ORG_TBL.EXT_ORG_ID%type; duplicateID INTEGER;BEGIN -- Loop through the base tables that contain EXT_ORG_ID. FOR rec in cBaseTables LOOP -- Insert into working table a list of both the base tables and any tables that use those base tables as a prompt. -- These are the list of tables that potentially need to be updated. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (&#39;&#39;&#39; || rec.x || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.RECNAME || &#39;&#39;&#39;, &#39;&#39;&#39; || rec.FIELDNAME || &#39;&#39;&#39;,0 ,0)&#39;; FindWhereRecUsedAsPrompt(rec.RECNAME, 1); END LOOP; -- Now we have a list of tables built we&#39;ll analyse how many rows we expect to update. -- PS_AMS_DUPID_RECNM.OCCURSCOUNT1 stores the number of rows that will be updated. analyseRowCount(&#39;OCCURSCOUNT1&#39;); -- Update the duplicate IDs (this is the really exciting part). For rec in cDuplicateIDs LOOP -- Create a new ID. duplicateID := 1; WHILE duplicateID 0 LOOP SELECT EMPLID_LAST_EMPL + 1 INTO newExtOrgId FROM PS_INSTALLATION; EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_PERSONAL_DATA WHERE EMPLID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; IF duplicateID = 0 THEN EXECUTE IMMEDIATE &#39;SELECT count(*) FROM PS_EXT_ORG_TBL WHERE EXT_ORG_ID = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;&#39; INTO duplicateID; --dbms_output.put_line(&#39;duplicateID= &#39; || duplicateID || &#39;, newExtOrgId= &#39; || newExtOrgId); END IF; END LOOP; UPDATE PS_INSTALLATION SET EMPLID_LAST_EMPL = newExtOrgId; -- Update the old value to the new value in every record that has at least one affected row. FOR recUpd in cTableList LOOP If recUpd.OCCURSCOUNT1 &gt; 0 THEN If substr(recUpd.RECNAME, 1, 2) = &#39;PS&#39; THEN sqlStatement:= &#39;UPDATE &#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; ELSE sqlStatement:= &#39;UPDATE PS_&#39; || recUpd.RECNAME || &#39; SET &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39; WHERE &#39; || recUpd.FIELDNAME || &#39; = &#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;&#39;; END IF; BEGIN EXECUTE IMMEDIATE sqlStatement; --dbms_output.put_line(sqlStatement); EXCEPTION WHEN OTHERS THEN dbms_output.put_line(&#39;Error at (main program): &#39; || sqlstatement); END; END IF; END LOOP; -- Record the old and new values. EXECUTE IMMEDIATE &#39;INSERT INTO PS_AMS_DUPID_OLDNW (EXT_ORG_ID_OLD, EXT_ORG_ID) VALUES (&#39;&#39;&#39; || rec.EXT_ORG_ID || &#39;&#39;&#39;, &#39;&#39;&#39; || newExtOrgId || &#39;&#39;&#39;)&#39;; END LOOP; -- Analyse the number of rows again. We expect 0. -- OCCURSCOUNT2 stores the number of rows post update/fix. Should be 0. analyseRowCount(&#39;OCCURSCOUNT2&#39;);END;/-- Show the analysis/working tables.select * from PS_AMS_DUPID_OLDNW;SELECT * FROM PS_AMS_DUPID_RECNM where occurscount1 &gt; 0;","@type":"BlogPosting","url":"http://localhost:4000/duplicate%20id%20pl/sql/2011/05/31/fixing-duplicate-student-and-organisation-ids.html","headline":"Fixing Duplicate Student and Organisation IDs","dateModified":"2011-05-31T07:44:00+10:00","datePublished":"2011-05-31T07:44:00+10:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/duplicate%20id%20pl/sql/2011/05/31/fixing-duplicate-student-and-organisation-ids.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="The PeopleSoft Experience" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">The PeopleSoft Experience</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Fixing Duplicate Student and Organisation IDs</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2011-05-31T07:44:00+10:00" itemprop="datePublished">May 31, 2011
      </time>â€¢ <span itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-author h-card" itemprop="name">{"login"=>"evlpanda", "email"=>"m.nitschke@gmail.com", "display_name"=>"Michael Nitschke", "first_name"=>"", "last_name"=>""}</span></span></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>Like this:</p>
<pre style="font-family:Andale Mono, Lucida Console, Monaco, fixed, monospace;color:#000000;background-color:#eee;font-size:12px;border:1px dashed #999999;line-height:14px;padding:5px;overflow:auto;width:100%;"><code>-- ************************************************************************************<br />-- CSUPGRD-727 Michael Nitschke 31/05/2011<br />-- Correct situation where Students and Organisations have duplicate IDs.<br />-- This has occurred where users have overwritten the 'NEW' value when adding an Org.<br />-- ************************************************************************************<br /><br />BEGIN<br />    -- Build working tables for this process.<br /><br />    -- This one stores all the Records that will potentially be updated.<br />    -- OCCURSCOUNT1 stores rows of data to be updated<br />    -- OCCURSCOUNT2 stores rows of data to be updated *after* the fix has been run. Should be 0.<br />    FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = 'PS_AMS_DUPID_RECNM') LOOP<br />        EXECUTE IMMEDIATE 'DROP TABLE PS_AMS_DUPID_RECNM';<br />    END LOOP;<br />    EXECUTE IMMEDIATE '<br />        CREATE TABLE PS_AMS_DUPID_RECNM (<br />            DESCR VARCHAR2(100) NOT NULL,<br />            RECNAME VARCHAR2(15) NOT NULL,<br />               FIELDNAME VARCHAR2(18) NOT NULL,<br />               OCCURSCOUNT1 SMALLINT NOT NULL,<br />            OCCURSCOUNT2 SMALLINT NOT NULL)<br />         TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80'<br />         ;<br /><br />    -- This one stores the old EXT_ORG_ID and the new EXT_ORG_ID for each Organisation that is having its ID updated.<br />    -- May be useful if something unexpected happens.<br />    FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = 'PS_AMS_DUPID_OLDNW') LOOP<br />        EXECUTE IMMEDIATE 'DROP TABLE PS_AMS_DUPID_OLDNW';<br />    END LOOP;<br />    EXECUTE IMMEDIATE '<br />        CREATE TABLE PS_AMS_DUPID_OLDNW (<br />            EXT_ORG_ID_OLD VARCHAR2(11) NOT NULL,<br />            EXT_ORG_ID VARCHAR2(11) NOT NULL)<br />        TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80'<br />        ;<br /><br />END;<br />/<br /><br />-- This procedure takes a given Record and finds all Records that use it as a prompt, where that prompt field is not EXT_ORG_ID (as record would be picked up in base select already).<br />-- Note that this function is recursive. Use the maxDepth value to set how far down the tree to go.<br />-- Too high a value and you will run out of cursors.<br />CREATE OR REPLACE PROCEDURE FindWhereRecUsedAsPrompt(varRecname VARCHAR2, currentDepth integer) IS<br /><br />    CURSOR cRecPrompts IS<br />        SELECT 'PROMPT' X, A.RECNAME AS RECNAME, A.FIELDNAME AS FIELDNAME<br />        FROM<br />          PSRECFIELD A<br />        , PSRECDEFN B<br />        , PSDBFIELD C<br />        WHERE A.FIELDNAME  'EXT_ORG_ID'<br />        AND A.EDITTABLE = varRecname<br />        AND B.RECNAME = A.RECNAME<br />        AND B.RECTYPE = 0  -- SQL Table<br />        AND C.FIELDNAME = A.FIELDNAME<br />        AND C.FIELDTYPE = 0; -- Character<br /><br />    depth integer;<br />    maxDepth integer;<br /><br />BEGIN<br /><br />    maxDepth:= 1; -- Set how deep you want to traverse down the prompt tables<br />    depth:= currentDepth;<br /><br />    FOR recP in cRecPrompts<br />    LOOP<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (''' || recP.x || '(depth: ' || depth || ', parent:' || varRecname || ')'' , ''' || recP.RECNAME || ''', ''' || recP.FIELDNAME || ''' ,0 ,0)';<br />        IF depth &lt; maxDepth THEN<br />            FindWhereRecUsedAsPrompt(recP.RECNAME, depth+1);<br />        END IF;<br />    END LOOP;<br />    depth:= depth-1;<br /><br />END FindWhereRecUsedAsPrompt;<br />/<br /><br />-- This procedure counts number of rows in affected tables.<br />-- It uses the temp table PS_AMS_DUPID_RECNM<br />-- OCCURSCOUNT1 stores the number of rows beofore the fix/update is applied.<br />-- OCCURSCOUNT2 stores the number of rows after the fix/update has been applied (should = 0).<br />CREATE OR REPLACE PROCEDURE analyseRowCount(fldUpdate VARCHAR2) IS<br /><br />    CURSOR cTableList IS<br />        SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM<br />        ;<br /><br />    sqlStatement VARCHAR2(300);<br />    rowCount INTEGER;<br /><br />BEGIN<br />    FOR rec in cTableList<br />    LOOP<br />        -- Two steps for legibility's sake.<br />        BEGIN<br />            If substr(rec.RECNAME, 1, 2) = 'PS'<br />            THEN<br />                sqlStatement:= 'SELECT COUNT(*) FROM ' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))';<br />--                dbms_output.put_line('SELECT COUNT(*) FROM ' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN ');<br />            ELSE<br />                sqlStatement:= 'SELECT COUNT(*) FROM PS_' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))';<br />--                dbms_output.put_line('SELECT COUNT(*) FROM PS_' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN ');<br />            END IF;<br /><br />            EXECUTE IMMEDIATE sqlStatement INTO rowCount;<br />            sqlStatement:= 'UPDATE PS_AMS_DUPID_RECNM SET ' || fldUpdate || ' = ' || rowCount || ' WHERE RECNAME = ''' || rec.RECNAME || ''' AND FIELDNAME = ''' || rec.FIELDNAME || '''';<br />            EXECUTE IMMEDIATE sqlStatement;<br /><br />        EXCEPTION<br />            WHEN OTHERS THEN<br />            dbms_output.put_line('Error at analyseRowCount(): ' || sqlstatement);<br />        END;<br /><br />    END LOOP;<br />END analyseRowCount;<br />/<br /><br /><br />------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br /><br /><br />-- &lt;&gt;<br />DECLARE<br /><br />    -- Duplicate IDs.<br />    CURSOR cDuplicateIDs IS<br />        SELECT<br />          EXT_ORG_ID<br />        FROM PS_EXT_ORG_TBL A<br />        WHERE A.EXT_ORG_ID IN<br />            (SELECT B.EXT_ORG_ID<br />            FROM PS_EXT_ORG_TBL B<br />            WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN<br />                (SELECT C.EMPLID<br />                FROM PS_PERSONAL_DATA C<br />                WHERE C.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))<br />        --and rownum &lt; 4 -- &lt;&lt; LOOK!!! used for building.<br />        ;<br /><br />    -- Base tables.<br />    -- Tables that have EXT_ORG_ID field.<br />    CURSOR cBaseTables IS<br />        SELECT<br />          'Base' X<br />        , A.RECNAME RECNAME<br />        , A.FIELDNAME FIELDNAME<br />        FROM<br />          PSRECFIELD A<br />        , PSRECDEFN B<br />        WHERE A.FIELDNAME = 'EXT_ORG_ID'<br />        AND B.RECNAME = A.RECNAME<br />        AND B.RECTYPE = 0<br />        AND B.RECNAME NOT LIKE '%TMP'<br />        AND NOT EXISTS -- Not used as an audit record.<br />            (SELECT 1<br />            FROM PSRECDEFN<br />            WHERE AUDITRECNAME = RECNAME)<br />        ;<br /><br />    CURSOR cTableList IS<br />        SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM<br />        ;<br /><br />    sqlStatement VARCHAR2(300);<br />    rowCount INTEGER;<br />    newExtOrgId PS_EXT_ORG_TBL.EXT_ORG_ID%type;<br />    duplicateID INTEGER;<br /><br />BEGIN<br /><br />    -- Loop through the base tables that contain EXT_ORG_ID.<br />    FOR rec in cBaseTables<br />    LOOP<br /><br />        -- Insert into working table a list of both the base tables and any tables that use those base tables as a prompt.<br />        -- These are the list of tables that potentially need to be updated.<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (''' || rec.x || ''', ''' || rec.RECNAME || ''', ''' || rec.FIELDNAME || ''',0 ,0)';<br />        FindWhereRecUsedAsPrompt(rec.RECNAME, 1);<br /><br />    END LOOP;<br /><br />    -- Now we have a list of tables built we'll analyse how many rows we expect to update.<br />    -- PS_AMS_DUPID_RECNM.OCCURSCOUNT1 stores the number of rows that will be updated.<br />    analyseRowCount('OCCURSCOUNT1');<br /><br />    -- Update the duplicate IDs (this is the really exciting part).<br />    For rec in cDuplicateIDs<br />    LOOP<br /><br />        -- Create a new ID.<br />        duplicateID := 1;<br />        WHILE duplicateID  0<br />        LOOP<br />            SELECT EMPLID_LAST_EMPL + 1 INTO newExtOrgId FROM PS_INSTALLATION;<br />            EXECUTE IMMEDIATE 'SELECT count(*) FROM PS_PERSONAL_DATA WHERE EMPLID = ''' || newExtOrgId || '''' INTO duplicateID;<br />            IF duplicateID = 0<br />            THEN<br />                EXECUTE IMMEDIATE 'SELECT count(*) FROM PS_EXT_ORG_TBL WHERE EXT_ORG_ID = ''' || newExtOrgId || '''' INTO duplicateID;<br />                --dbms_output.put_line('duplicateID= ' || duplicateID || ', newExtOrgId= ' || newExtOrgId);<br />            END IF;<br />        END LOOP;<br />        UPDATE PS_INSTALLATION SET EMPLID_LAST_EMPL = newExtOrgId;<br /><br />        -- Update the old value to the new value in every record that has at least one affected row.<br />        FOR recUpd in cTableList<br />        LOOP<br />            If recUpd.OCCURSCOUNT1 &gt; 0 THEN<br /><br />                If substr(recUpd.RECNAME, 1, 2) = 'PS'<br />                THEN<br />                    sqlStatement:= 'UPDATE ' || recUpd.RECNAME || ' SET ' || recUpd.FIELDNAME || ' = ''' || newExtOrgId || ''' WHERE ' || recUpd.FIELDNAME || ' = ''' || rec.EXT_ORG_ID || '''';<br />                ELSE<br />                    sqlStatement:= 'UPDATE PS_' || recUpd.RECNAME || ' SET ' || recUpd.FIELDNAME || ' = ''' || newExtOrgId || ''' WHERE ' || recUpd.FIELDNAME || ' = ''' || rec.EXT_ORG_ID || '''';<br />                END IF;<br /><br />                BEGIN<br />                    EXECUTE IMMEDIATE sqlStatement;<br />                    --dbms_output.put_line(sqlStatement);<br />                EXCEPTION<br />                    WHEN OTHERS THEN<br />                    dbms_output.put_line('Error at (main program): ' || sqlstatement);<br />                END;<br /><br />            END IF;<br />        END LOOP;<br /><br />        -- Record the old and new values.<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_OLDNW (EXT_ORG_ID_OLD, EXT_ORG_ID) VALUES (''' || rec.EXT_ORG_ID || ''', ''' || newExtOrgId || ''')';<br /><br />    END LOOP;<br /><br />    -- Analyse the number of rows again. We expect 0.<br />    -- OCCURSCOUNT2 stores the number of rows post update/fix. Should be 0.<br />    analyseRowCount('OCCURSCOUNT2');<br /><br />END;<br />/<br /><br />-- Show the analysis/working tables.<br />select * from PS_AMS_DUPID_OLDNW;<br />SELECT * FROM PS_AMS_DUPID_RECNM where occurscount1 &gt; 0;<br /><br /></code></pre>

  </div><a class="u-url" href="/duplicate%20id%20pl/sql/2011/05/31/fixing-duplicate-student-and-organisation-ids.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">The PeopleSoft Experience</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">The PeopleSoft Experience</li><li><a class="u-email" href="mailto:your-email@example.com">your-email@example.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/evlPanda"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">evlPanda</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Musings, chit-chat, and sometimes useful stuff related to PeopleSoft, especially PeopleCode.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
