---
layout: post
title: Fixing Duplicate Student and Organisation IDs
date: 2011-05-31 07:44:00.000000000 +10:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories:
- duplicate id pl/sql
tags: []
meta:
  blogger_blog: capital-it.blogspot.com
  blogger_author: Michael Nitschke
  blogger_0c9a3d51488c214aefd1a54a659341d6_permalink: '6464126340537474260'
author:
  login: evlpanda
  email: m.nitschke@gmail.com
  display_name: Michael Nitschke
  first_name: ''
  last_name: ''
---
<p>Like this:</p>
<pre style="font-family:Andale Mono, Lucida Console, Monaco, fixed, monospace;color:#000000;background-color:#eee;font-size:12px;border:1px dashed #999999;line-height:14px;padding:5px;overflow:auto;width:100%;"><code>-- ************************************************************************************<br />-- CSUPGRD-727 Michael Nitschke 31/05/2011<br />-- Correct situation where Students and Organisations have duplicate IDs.<br />-- This has occurred where users have overwritten the 'NEW' value when adding an Org.<br />-- ************************************************************************************<br /><br />BEGIN<br />    -- Build working tables for this process.<br /><br />    -- This one stores all the Records that will potentially be updated.<br />    -- OCCURSCOUNT1 stores rows of data to be updated<br />    -- OCCURSCOUNT2 stores rows of data to be updated *after* the fix has been run. Should be 0.<br />    FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = 'PS_AMS_DUPID_RECNM') LOOP<br />        EXECUTE IMMEDIATE 'DROP TABLE PS_AMS_DUPID_RECNM';<br />    END LOOP;<br />    EXECUTE IMMEDIATE '<br />        CREATE TABLE PS_AMS_DUPID_RECNM (<br />            DESCR VARCHAR2(100) NOT NULL,<br />            RECNAME VARCHAR2(15) NOT NULL,<br />               FIELDNAME VARCHAR2(18) NOT NULL,<br />               OCCURSCOUNT1 SMALLINT NOT NULL,<br />            OCCURSCOUNT2 SMALLINT NOT NULL)<br />         TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80'<br />         ;<br /><br />    -- This one stores the old EXT_ORG_ID and the new EXT_ORG_ID for each Organisation that is having its ID updated.<br />    -- May be useful if something unexpected happens.<br />    FOR i IN (SELECT TABLE_NAME FROM USER_TABLES WHERE TABLE_NAME = 'PS_AMS_DUPID_OLDNW') LOOP<br />        EXECUTE IMMEDIATE 'DROP TABLE PS_AMS_DUPID_OLDNW';<br />    END LOOP;<br />    EXECUTE IMMEDIATE '<br />        CREATE TABLE PS_AMS_DUPID_OLDNW (<br />            EXT_ORG_ID_OLD VARCHAR2(11) NOT NULL,<br />            EXT_ORG_ID VARCHAR2(11) NOT NULL)<br />        TABLESPACE SAAPP STORAGE (INITIAL 40000 NEXT 100000 MAXEXTENTS UNLIMITED PCTINCREASE 0) PCTFREE 10 PCTUSED 80'<br />        ;<br /><br />END;<br />/<br /><br />-- This procedure takes a given Record and finds all Records that use it as a prompt, where that prompt field is not EXT_ORG_ID (as record would be picked up in base select already).<br />-- Note that this function is recursive. Use the maxDepth value to set how far down the tree to go.<br />-- Too high a value and you will run out of cursors.<br />CREATE OR REPLACE PROCEDURE FindWhereRecUsedAsPrompt(varRecname VARCHAR2, currentDepth integer) IS<br /><br />    CURSOR cRecPrompts IS<br />        SELECT 'PROMPT' X, A.RECNAME AS RECNAME, A.FIELDNAME AS FIELDNAME<br />        FROM<br />          PSRECFIELD A<br />        , PSRECDEFN B<br />        , PSDBFIELD C<br />        WHERE A.FIELDNAME  'EXT_ORG_ID'<br />        AND A.EDITTABLE = varRecname<br />        AND B.RECNAME = A.RECNAME<br />        AND B.RECTYPE = 0  -- SQL Table<br />        AND C.FIELDNAME = A.FIELDNAME<br />        AND C.FIELDTYPE = 0; -- Character<br /><br />    depth integer;<br />    maxDepth integer;<br /><br />BEGIN<br /><br />    maxDepth:= 1; -- Set how deep you want to traverse down the prompt tables<br />    depth:= currentDepth;<br /><br />    FOR recP in cRecPrompts<br />    LOOP<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (''' || recP.x || '(depth: ' || depth || ', parent:' || varRecname || ')'' , ''' || recP.RECNAME || ''', ''' || recP.FIELDNAME || ''' ,0 ,0)';<br />        IF depth &lt; maxDepth THEN<br />            FindWhereRecUsedAsPrompt(recP.RECNAME, depth+1);<br />        END IF;<br />    END LOOP;<br />    depth:= depth-1;<br /><br />END FindWhereRecUsedAsPrompt;<br />/<br /><br />-- This procedure counts number of rows in affected tables.<br />-- It uses the temp table PS_AMS_DUPID_RECNM<br />-- OCCURSCOUNT1 stores the number of rows beofore the fix/update is applied.<br />-- OCCURSCOUNT2 stores the number of rows after the fix/update has been applied (should = 0).<br />CREATE OR REPLACE PROCEDURE analyseRowCount(fldUpdate VARCHAR2) IS<br /><br />    CURSOR cTableList IS<br />        SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM<br />        ;<br /><br />    sqlStatement VARCHAR2(300);<br />    rowCount INTEGER;<br /><br />BEGIN<br />    FOR rec in cTableList<br />    LOOP<br />        -- Two steps for legibility's sake.<br />        BEGIN<br />            If substr(rec.RECNAME, 1, 2) = 'PS'<br />            THEN<br />                sqlStatement:= 'SELECT COUNT(*) FROM ' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))';<br />--                dbms_output.put_line('SELECT COUNT(*) FROM ' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN ');<br />            ELSE<br />                sqlStatement:= 'SELECT COUNT(*) FROM PS_' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN (SELECT SUBSTR(EXT_ORG_ID,1,7) FROM PS_EXT_ORG_TBL B WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN (SELECT A.EMPLID FROM PS_PERSONAL_DATA A WHERE A.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))';<br />--                dbms_output.put_line('SELECT COUNT(*) FROM PS_' || rec.RECNAME || ' WHERE SUBSTR(' || rec.FIELDNAME || ',1,7) IN ');<br />            END IF;<br /><br />            EXECUTE IMMEDIATE sqlStatement INTO rowCount;<br />            sqlStatement:= 'UPDATE PS_AMS_DUPID_RECNM SET ' || fldUpdate || ' = ' || rowCount || ' WHERE RECNAME = ''' || rec.RECNAME || ''' AND FIELDNAME = ''' || rec.FIELDNAME || '''';<br />            EXECUTE IMMEDIATE sqlStatement;<br /><br />        EXCEPTION<br />            WHEN OTHERS THEN<br />            dbms_output.put_line('Error at analyseRowCount(): ' || sqlstatement);<br />        END;<br /><br />    END LOOP;<br />END analyseRowCount;<br />/<br /><br /><br />------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------<br /><br /><br />-- &lt;&gt;<br />DECLARE<br /><br />    -- Duplicate IDs.<br />    CURSOR cDuplicateIDs IS<br />        SELECT<br />          EXT_ORG_ID<br />        FROM PS_EXT_ORG_TBL A<br />        WHERE A.EXT_ORG_ID IN<br />            (SELECT B.EXT_ORG_ID<br />            FROM PS_EXT_ORG_TBL B<br />            WHERE SUBSTR(B.EXT_ORG_ID,1,7) IN<br />                (SELECT C.EMPLID<br />                FROM PS_PERSONAL_DATA C<br />                WHERE C.EMPLID = SUBSTR(B.EXT_ORG_ID,1,7)))<br />        --and rownum &lt; 4 -- &lt;&lt; LOOK!!! used for building.<br />        ;<br /><br />    -- Base tables.<br />    -- Tables that have EXT_ORG_ID field.<br />    CURSOR cBaseTables IS<br />        SELECT<br />          'Base' X<br />        , A.RECNAME RECNAME<br />        , A.FIELDNAME FIELDNAME<br />        FROM<br />          PSRECFIELD A<br />        , PSRECDEFN B<br />        WHERE A.FIELDNAME = 'EXT_ORG_ID'<br />        AND B.RECNAME = A.RECNAME<br />        AND B.RECTYPE = 0<br />        AND B.RECNAME NOT LIKE '%TMP'<br />        AND NOT EXISTS -- Not used as an audit record.<br />            (SELECT 1<br />            FROM PSRECDEFN<br />            WHERE AUDITRECNAME = RECNAME)<br />        ;<br /><br />    CURSOR cTableList IS<br />        SELECT DISTINCT RECNAME, FIELDNAME, OCCURSCOUNT1 FROM PS_AMS_DUPID_RECNM<br />        ;<br /><br />    sqlStatement VARCHAR2(300);<br />    rowCount INTEGER;<br />    newExtOrgId PS_EXT_ORG_TBL.EXT_ORG_ID%type;<br />    duplicateID INTEGER;<br /><br />BEGIN<br /><br />    -- Loop through the base tables that contain EXT_ORG_ID.<br />    FOR rec in cBaseTables<br />    LOOP<br /><br />        -- Insert into working table a list of both the base tables and any tables that use those base tables as a prompt.<br />        -- These are the list of tables that potentially need to be updated.<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_RECNM (DESCR, RECNAME, FIELDNAME, OCCURSCOUNT1, OCCURSCOUNT2) VALUES (''' || rec.x || ''', ''' || rec.RECNAME || ''', ''' || rec.FIELDNAME || ''',0 ,0)';<br />        FindWhereRecUsedAsPrompt(rec.RECNAME, 1);<br /><br />    END LOOP;<br /><br />    -- Now we have a list of tables built we'll analyse how many rows we expect to update.<br />    -- PS_AMS_DUPID_RECNM.OCCURSCOUNT1 stores the number of rows that will be updated.<br />    analyseRowCount('OCCURSCOUNT1');<br /><br />    -- Update the duplicate IDs (this is the really exciting part).<br />    For rec in cDuplicateIDs<br />    LOOP<br /><br />        -- Create a new ID.<br />        duplicateID := 1;<br />        WHILE duplicateID  0<br />        LOOP<br />            SELECT EMPLID_LAST_EMPL + 1 INTO newExtOrgId FROM PS_INSTALLATION;<br />            EXECUTE IMMEDIATE 'SELECT count(*) FROM PS_PERSONAL_DATA WHERE EMPLID = ''' || newExtOrgId || '''' INTO duplicateID;<br />            IF duplicateID = 0<br />            THEN<br />                EXECUTE IMMEDIATE 'SELECT count(*) FROM PS_EXT_ORG_TBL WHERE EXT_ORG_ID = ''' || newExtOrgId || '''' INTO duplicateID;<br />                --dbms_output.put_line('duplicateID= ' || duplicateID || ', newExtOrgId= ' || newExtOrgId);<br />            END IF;<br />        END LOOP;<br />        UPDATE PS_INSTALLATION SET EMPLID_LAST_EMPL = newExtOrgId;<br /><br />        -- Update the old value to the new value in every record that has at least one affected row.<br />        FOR recUpd in cTableList<br />        LOOP<br />            If recUpd.OCCURSCOUNT1 &gt; 0 THEN<br /><br />                If substr(recUpd.RECNAME, 1, 2) = 'PS'<br />                THEN<br />                    sqlStatement:= 'UPDATE ' || recUpd.RECNAME || ' SET ' || recUpd.FIELDNAME || ' = ''' || newExtOrgId || ''' WHERE ' || recUpd.FIELDNAME || ' = ''' || rec.EXT_ORG_ID || '''';<br />                ELSE<br />                    sqlStatement:= 'UPDATE PS_' || recUpd.RECNAME || ' SET ' || recUpd.FIELDNAME || ' = ''' || newExtOrgId || ''' WHERE ' || recUpd.FIELDNAME || ' = ''' || rec.EXT_ORG_ID || '''';<br />                END IF;<br /><br />                BEGIN<br />                    EXECUTE IMMEDIATE sqlStatement;<br />                    --dbms_output.put_line(sqlStatement);<br />                EXCEPTION<br />                    WHEN OTHERS THEN<br />                    dbms_output.put_line('Error at (main program): ' || sqlstatement);<br />                END;<br /><br />            END IF;<br />        END LOOP;<br /><br />        -- Record the old and new values.<br />        EXECUTE IMMEDIATE 'INSERT INTO PS_AMS_DUPID_OLDNW (EXT_ORG_ID_OLD, EXT_ORG_ID) VALUES (''' || rec.EXT_ORG_ID || ''', ''' || newExtOrgId || ''')';<br /><br />    END LOOP;<br /><br />    -- Analyse the number of rows again. We expect 0.<br />    -- OCCURSCOUNT2 stores the number of rows post update/fix. Should be 0.<br />    analyseRowCount('OCCURSCOUNT2');<br /><br />END;<br />/<br /><br />-- Show the analysis/working tables.<br />select * from PS_AMS_DUPID_OLDNW;<br />SELECT * FROM PS_AMS_DUPID_RECNM where occurscount1 &gt; 0;<br /><br /></code></pre>
