---
layout: post
title: SQL Select Date Range
date: 2016-08-03 05:33:08.000000000 +10:00
type: post
parent_id: '0'
published: true
password: ''
status: publish
categories: []
tags: []
meta:
  _rest_api_published: '1'
  _rest_api_client_id: "-1"
  _publicize_job_id: '25419394768'
author:
  login: evlpanda
  email: m.nitschke@gmail.com
  display_name: Michael Nitschke
  first_name: ''
  last_name: ''
---
<p>This SQL will select, or delete, an entire "date range" if one or more of the days in that range meets a certain criteria.</p>
<p>This uses recursion to find all the adjoining dates in the range - the cool bit.</p>
<pre>
<code>
--- Dummy Data ------------------------------------------

-- Employees are eligible for different types across a range of dates (exploded):
with data (emplid, date, type) as (
	select 123, date('2016-01-01'), 'A' from sysibm.sysdummy1 union
	select 123, date('2016-01-02'), 'A' from sysibm.sysdummy1 union
	select 123, date('2016-01-03'), 'B' from sysibm.sysdummy1 union
	select 123, date('2016-01-04'), 'B' from sysibm.sysdummy1 union
	select 123, date('2016-01-05'), 'B' from sysibm.sysdummy1 union
	select 123, date('2016-01-06'), 'B' from sysibm.sysdummy1 union
	select 123, date('2016-01-07'), 'B' from sysibm.sysdummy1 union
	select 123, date('2016-01-08'), 'A' from sysibm.sysdummy1 union
	select 123, date('2016-01-09'), 'A' from sysibm.sysdummy1 
)

-- Members are in certain pay groups:
, paygroup (emplid, paygroup, bgn_dt, end_dt) as (
	select 123, 'YES', date('2015-07-01'), date('2016-01-06') from sysibm.sysdummy1 union
	select 123, 'NO' , date('2016-01-07'), date('2016-01-20') from sysibm.sysdummy1 union
	select 123, 'YES', date('2016-01-21'), date('2016-06-30') from sysibm.sysdummy1
)

--- Solution ---------------------------------------------

-- Find the dates they are in the invalid pay group (easy bit)
, invalid (emplid, date, type) as (
	select data.emplid, data.date, data.type
	from data, paygroup 
	where paygroup.emplid = data.emplid
	and paygroup.paygroup = 'NO'
	and data.date between paygroup.bgn_dt and paygroup.end_dt
	and data.type = 'B'
)

-- Find all *adjoining* dates of the same type, prior:
, toDeleteA (emplid, date, type) as (
	select emplid, date, type from invalid
	union all
	select data.emplid, data.date, data.type
	from data, toDeleteA
	where toDeleteA.date - 1 day = data.date 
	and toDeleteA.type = data.type
)

-- Find all *adjoining* dates of the same type, post:
, toDeleteB (emplid, date, type) as (
	select emplid, date, type from invalid
	union all
	select data.emplid, data.date, data.type
	from data, toDeleteB
	where toDeleteB.date + 1 day = data.date 
	and toDeleteB.type = data.type
)

-- Combine:
, toDelete as (
	select * from toDeleteA 
	union
	select * from toDeleteB
)

-- Voila!
-- delete * from data
select * from data
where exists
	(select 1
	from toDelete
	where data.emplid = toDelete.emplid
	and data.date = toDelete.date
	and data.type = toDelete.type)
;
</code>
</pre>
